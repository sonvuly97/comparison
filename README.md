# comparison
Анализ алгоритма: Сортировка выбором (Selection Sort)

   Определение: Данный алгоритм основывается на разделении массива на отсортированную и неотсортированную области. На каждом этапе в неотсортированной части отыскивается наименьший элемент, который затем помещается в конец отсортированной последовательности.
   
   Анализ:
       Механизм работы заключается в последовательном поиске минимума в неотсортированном сегменте массива и его обмене с элементом на текущей позиции.
       Внешний цикл совершает `n-1` проходов по массиву.
       Внутренний цикл с каждой итерацией внешнего цикла просматривает на один элемент меньше: сначала `n-1` сравнение, затем `n-2` и так далее.
       Суммарное количество операций сравнения асимптотически оценивается как `n*(n-1)/2`.
      
       Временная сложность: O(n²).
       
       Обоснование сложности O(n²): Наличие двух вложенных циклов, каждый из которых в худшем и среднем случае линейно зависит от `n`, приводит к квадратичной зависимости общего количества операций. Внутренний цикл выполняется порядка `n` раз для каждого из `n` проходов внешнего.

Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)

Определение: Этот простой алгоритм последовательно обходит массив, попарно сравнивая соседние элементы и меняя их местами, когда это необходимо. Процесс повторяется до тех пор, пока массив не будет полностью упорядочен.

Анализ:
     В процессе выполнения алгоритма наибольшие элементы постепенно "всплывают" к концу массива, подобно пузырькам воздуха в воде.
    Внешний цикл также выполняется до `n-1` раз.
    Внутренний цикл в худшем сценарии (изначально обратный порядок) совершает `n-1`, `n-2`, ... операций сравнения и обмена.
    Использование флага `swapped` для отслеживания факта обмена на проходе позволяет досрочно завершить работу, если массив уже отсортирован.
       
       Временная сложность:
           Худший случай: O(n²) — элементы расположены в обратном порядке.
           Лучший случай: O(n) — массив изначально отсортирован (при использовании оптимизации с флагом).
           Средний случай: O(n²).
    
     Обоснование сложности O(n²): В худшем случае, аналогично сортировке выбором, количество требуемых сравнений и обменов пропорционально `n*(n-1)/2`, что дает квадратичную зависимость.
Конечно, вот перефразированные версии всех пунктов:

Анализ алгоритма: Сортировка вставками (Insertion Sort)

   Определение: Этот алгоритм последовательно обрабатывает элементы массива, вставляя каждый новый элемент в правильную позицию внутри уже упорядоченной части последовательности.
   
   Анализ:
       Отсортированный сегмент формируется слева направо. Каждый следующий элемент "вставляется" в отсортированную часть, для чего более крупные элементы сдвигаются вправо.
       Внешний цикл обрабатывает `n-1` элементов.
       Внутренний цикл в худшем сценарии (обратная сортировка) для `i-го` элемента может потребовать до `i` сдвигов.
       
       Временная сложность:
        Худший случай: O(n²) — каждый новый элемент требует сдвига почти всей отсортированной части.
        Лучший случай: O(n) — массив уже отсортирован, внутренний цикл практически не работает.
        Средний случай: O(n²).
       
       Обоснование сложности O(n²): В худшем случае общее число операций представляет собой арифметическую прогрессию: 1 + 2 + ... + (n-1) = n*(n-1)/2.
       
Анализ алгоритма: Сортировка слиянием (Merge Sort)

   Определение: Это алгоритм, работающий по принципу "разделяй и властвуй": массив рекурсивно разбивается на мелкие части до тех пор, пока они не станут тривиальными для сортировки, после чего эти части сливаются в упорядоченные сегменты.
  
   Анализ:
       Процесс включает две основные фазы: рекурсивное разделение массива на подмассивы из одного элемента и их последующее слияние в упорядоченном виде.
       Функция слияния (merge) объединяет два отсортированных подмассива в один, выполняя линейное количество операций.
      
       Временная сложность: O(n log n).
       Обоснование сложности O(n log n):
           Глубина рекурсии: Массив делится пополам на каждом уровне, что создает `log n` уровней рекурсии.
           Работа на уровне: На каждом уровне рекурсии операция слияния в сумме затрагивает все `n` элементов массива.
           Итог: `log n` уровней × `n` операций на уровень = O(n log n).

Анализ алгоритма: Сортировка Шелла (Shell Sort)

   Определение: Усовершенствованный вариант сортировки вставками, который сортирует элементы, отстоящие друг от друга на некотором расстоянии (шаге), постепенно уменьшая этот шаг до единицы.
   
   Анализ:
       Алгоритм выполняет несколько проходов с разными значениями шага (gap). На каждом проходе сортируются элементы, разделенные этим шагом.
       Эффективность сильно зависит от выбранной последовательности шагов.
      
       Временная сложность: Зависит от последовательности шагов.
       Для последовательности `n/2, n/4, ... 1` сложность составляет около O(n²) в худшем случае, но на практике часто лучше.
      Для последовательности Кнута (3h+1) — O(n^(3/2)).
      В общем виде оценивается как O(n^p), где 1 < p < 2.
      
       Обоснование сложности: Хотя алгоритм использует вложенные циклы, благодаря предварительной сортировке на больших шагах, количество операций во внутреннем цикле сокращается. Это приводит к производительности, промежуточной между O(n) и O(n²).

Анализ алгоритма: Быстрая сортировка (Quick Sort)**

   Определение: Эффективный алгоритм, основанный на стратегии "разделяй и властвуй", который выбирает опорный элемент и разбивает массив на элементы меньше и больше опорного, после чего рекурсивно сортирует эти части.
  
   Анализ:
       Ключевой этап — разбиение (partition). Качество разбиения (сбалансированность частей) напрямую влияет на производительность.
       
       Временная сложность:
          Средний случай: O(n log n) — достигается при относительно равномерном разбиении на каждом шаге.
          Худший случай: O(n²) — возникает, когда опорный элемент постоянно оказывается минимальным или максимальным (например, в уже отсортированном массиве при неудачном выборе опоры).
          Лучший случай: O(n log n) — достигается при идеальном разбиении массива пополам.
      
       Обоснование сложности:
           Средний/Лучший: Глубина рекурсии — O(log n), а работа на каждом уровне — O(n), что в сумме дает O(n log n).
           Худший: Глубина рекурсии вырождается до O(n), а работа на уровне остается O(n), что приводит к O(n²).

Анализ алгоритма: Пирамидальная сортировка (Heap Sort)

   Определение: Алгоритм, который использует структуру данных "двоичная куча" (пирамида) для сортировки элементов.   
   
   Анализ:
       Процесс состоит из двух этапов: построение max-кучи из исходного массива и последовательное извлечение максимального элемента (корня) с последующим восстановлением свойств кучи.
      
       Временная сложность: O(n log n).
       
       Обоснование сложности O(n log n):
           Построение кучи: Может быть выполнено за O(n) операций, так как большинство элементов просеиваются на небольшой глубине.
           Фаза сортировки: Требует `n-1` извлечений корня, каждое из которых сопровождается процедурой восстановления кучи, работающей за O(log n). Итог: O(n log n).
           Суммарно: O(n) + O(n log n) = O(n log n).

Анализ алгоритма: Последовательный поиск (Linear Search)

   Определение: Простейший алгоритм поиска, который проверяет каждый элемент структуры данных по порядку до тех пор, пока не будет найден целевой элемент или не будет достигнут конец.
   
   Анализ:
      Алгоритм не требует предварительной подготовки данных (сортировки).
     
      Временная сложность:
           Худший случай: O(n) — элемент отсутствует или находится в конце.
           Лучший случай: O(1) — элемент находится в начале.
           Средний случай: O(n) — в среднем требуется проверить около половины элементов.
       
       Обоснование O(n): В худшем случае необходимо проверить все `n` элементов.

Анализ алгоритма: Бинарный поиск (Binary Search)

   Определение: Алгоритм для нахождения позиции элемента в отсортированном массиве путем многократного деления интервала поиска пополам.
   
   Анализ:
       Основное требование — массив должен быть отсортирован.
       На каждом шаге алгоритм сравнивает искомый элемент со средним элементом текущего интервала и отбрасывает одну из половин.
      
       Временная сложность: O(log n).
      
       Обоснование O(log n): На каждом шаге размер области поиска сокращается вдвое. Количество шагов, необходимое для уменьшения интервала с `n` до 1, равно log₂n.

Анализ алгоритма: Интерполяционный поиск (Interpolation Search)

   Определение: Алгоритм поиска в отсортированном массиве, который предсказывает позицию искомого элемента на основе его значения и значений на границах, что эффективно при равномерном распределении данных.
   
   Анализ:
       Вместо деления пополам, алгоритм вычисляет вероятную позицию элемента, используя линейную интерполяцию.
      
       Временная сложность:**
           Средний случай (равномерное распределение): O(log log n).
           Худший случай (сильно неравномерное распределение): O(n).
       
       Обоснование сложности:
           Средний: При равномерном распределении размер интервала сокращается на каждом шаге гораздо быстрее, чем в бинарном поиске, что приводит к двойному логарифму.
           Худший: В случае неудачного распределения данных алгоритм может выродиться до последовательного перебора.

Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)

   Определение: Алгоритм, использующий числа Фибоначчи для определения точек разделения в отсортированном массиве, схожий по идее с бинарным поиском, но использующий другое соотношение частей.
   
   Анализ:
       Алгоритм оперирует числами Фибоначчи для сужения области поиска, избегая использования операции деления.
      
       Временная сложность: O(log n).
       
       Обоснование O(log n): Количество чисел Фибоначчи, не превосходящих `n`, пропорционально log n. Поиск требует количества итераций, пропорционального этому количеству.
